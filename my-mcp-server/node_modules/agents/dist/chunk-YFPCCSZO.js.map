{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import {\n  Server,\n  routePartykitRequest,\n  type PartyServerOptions,\n  getServerByName,\n  type Connection,\n  type ConnectionContext,\n  type WSMessage,\n} from \"partyserver\";\n\nimport { parseCronExpression } from \"cron-schedule\";\nimport { nanoid } from \"nanoid\";\n\nimport { AsyncLocalStorage } from \"node:async_hooks\";\nimport { MCPClientManager } from \"./mcp/client\";\nimport {\n  DurableObjectOAuthClientProvider,\n  type AgentsOAuthProvider,\n} from \"./mcp/do-oauth-client-provider\";\nimport type {\n  Tool,\n  Resource,\n  Prompt,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nimport type { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\n\nimport { camelCaseToKebabCase } from \"./client\";\n\nexport type { Connection, WSMessage, ConnectionContext } from \"partyserver\";\n\n/**\n * RPC request message from client\n */\nexport type RPCRequest = {\n  type: \"rpc\";\n  id: string;\n  method: string;\n  args: unknown[];\n};\n\n/**\n * State update message from client\n */\nexport type StateUpdateMessage = {\n  type: \"cf_agent_state\";\n  state: unknown;\n};\n\n/**\n * RPC response message to client\n */\nexport type RPCResponse = {\n  type: \"rpc\";\n  id: string;\n} & (\n  | {\n      success: true;\n      result: unknown;\n      done?: false;\n    }\n  | {\n      success: true;\n      result: unknown;\n      done: true;\n    }\n  | {\n      success: false;\n      error: string;\n    }\n);\n\n/**\n * Type guard for RPC request messages\n */\nfunction isRPCRequest(msg: unknown): msg is RPCRequest {\n  return (\n    typeof msg === \"object\" &&\n    msg !== null &&\n    \"type\" in msg &&\n    msg.type === \"rpc\" &&\n    \"id\" in msg &&\n    typeof msg.id === \"string\" &&\n    \"method\" in msg &&\n    typeof msg.method === \"string\" &&\n    \"args\" in msg &&\n    Array.isArray((msg as RPCRequest).args)\n  );\n}\n\n/**\n * Type guard for state update messages\n */\nfunction isStateUpdateMessage(msg: unknown): msg is StateUpdateMessage {\n  return (\n    typeof msg === \"object\" &&\n    msg !== null &&\n    \"type\" in msg &&\n    msg.type === \"cf_agent_state\" &&\n    \"state\" in msg\n  );\n}\n\n/**\n * Metadata for a callable method\n */\nexport type CallableMetadata = {\n  /** Optional description of what the method does */\n  description?: string;\n  /** Whether the method supports streaming responses */\n  streaming?: boolean;\n};\n\n// biome-ignore lint/complexity/noBannedTypes: <explanation>\nconst callableMetadata = new Map<Function, CallableMetadata>();\n\n/**\n * Decorator that marks a method as callable by clients\n * @param metadata Optional metadata about the callable method\n */\nexport function unstable_callable(metadata: CallableMetadata = {}) {\n  return function callableDecorator<This, Args extends unknown[], Return>(\n    target: (this: This, ...args: Args) => Return,\n    context: ClassMethodDecoratorContext\n  ) {\n    if (!callableMetadata.has(target)) {\n      callableMetadata.set(target, metadata);\n    }\n\n    return target;\n  };\n}\n\n/**\n * Represents a scheduled task within an Agent\n * @template T Type of the payload data\n */\nexport type Schedule<T = string> = {\n  /** Unique identifier for the schedule */\n  id: string;\n  /** Name of the method to be called */\n  callback: string;\n  /** Data to be passed to the callback */\n  payload: T;\n} & (\n  | {\n      /** Type of schedule for one-time execution at a specific time */\n      type: \"scheduled\";\n      /** Timestamp when the task should execute */\n      time: number;\n    }\n  | {\n      /** Type of schedule for delayed execution */\n      type: \"delayed\";\n      /** Timestamp when the task should execute */\n      time: number;\n      /** Number of seconds to delay execution */\n      delayInSeconds: number;\n    }\n  | {\n      /** Type of schedule for recurring execution based on cron expression */\n      type: \"cron\";\n      /** Timestamp for the next execution */\n      time: number;\n      /** Cron expression defining the schedule */\n      cron: string;\n    }\n);\n\nfunction getNextCronTime(cron: string) {\n  const interval = parseCronExpression(cron);\n  return interval.getNextDate();\n}\n\n/**\n * MCP Server state update message from server -> Client\n */\nexport type MCPServerMessage = {\n  type: \"cf_agent_mcp_servers\";\n  mcp: MCPServersState;\n};\n\nexport type MCPServersState = {\n  servers: {\n    [id: string]: MCPServer;\n  };\n  tools: Tool[];\n  prompts: Prompt[];\n  resources: Resource[];\n};\n\nexport type MCPServer = {\n  name: string;\n  server_url: string;\n  auth_url: string | null;\n  state: \"authenticating\" | \"connecting\" | \"ready\" | \"discovering\" | \"failed\";\n};\n\n/**\n * MCP Server data stored in DO SQL for resuming MCP Server connections\n */\ntype MCPServerRow = {\n  id: string;\n  name: string;\n  server_url: string;\n  client_id: string | null;\n  auth_url: string | null;\n  callback_url: string;\n  server_options: string;\n};\n\nconst STATE_ROW_ID = \"cf_state_row_id\";\nconst STATE_WAS_CHANGED = \"cf_state_was_changed\";\n\nconst DEFAULT_STATE = {} as unknown;\n\nconst agentContext = new AsyncLocalStorage<{\n  agent: Agent<unknown>;\n  connection: Connection | undefined;\n  request: Request | undefined;\n}>();\n\nexport function getCurrentAgent<\n  T extends Agent<unknown, unknown> = Agent<unknown, unknown>,\n>(): {\n  agent: T | undefined;\n  connection: Connection | undefined;\n  request: Request<unknown, CfProperties<unknown>> | undefined;\n} {\n  const store = agentContext.getStore() as\n    | {\n        agent: T;\n        connection: Connection | undefined;\n        request: Request<unknown, CfProperties<unknown>> | undefined;\n      }\n    | undefined;\n  if (!store) {\n    return {\n      agent: undefined,\n      connection: undefined,\n      request: undefined,\n    };\n  }\n  return store;\n}\n\n/**\n * Base class for creating Agent implementations\n * @template Env Environment type containing bindings\n * @template State State type to store within the Agent\n */\nexport class Agent<Env, State = unknown> extends Server<Env> {\n  #state = DEFAULT_STATE as State;\n\n  #ParentClass: typeof Agent<Env, State> =\n    Object.getPrototypeOf(this).constructor;\n\n  mcp: MCPClientManager = new MCPClientManager(this.#ParentClass.name, \"0.0.1\");\n\n  /**\n   * Initial state for the Agent\n   * Override to provide default state values\n   */\n  initialState: State = DEFAULT_STATE as State;\n\n  /**\n   * Current state of the Agent\n   */\n  get state(): State {\n    if (this.#state !== DEFAULT_STATE) {\n      // state was previously set, and populated internal state\n      return this.#state;\n    }\n    // looks like this is the first time the state is being accessed\n    // check if the state was set in a previous life\n    const wasChanged = this.sql<{ state: \"true\" | undefined }>`\n        SELECT state FROM cf_agents_state WHERE id = ${STATE_WAS_CHANGED}\n      `;\n\n    // ok, let's pick up the actual state from the db\n    const result = this.sql<{ state: State | undefined }>`\n      SELECT state FROM cf_agents_state WHERE id = ${STATE_ROW_ID}\n    `;\n\n    if (\n      wasChanged[0]?.state === \"true\" ||\n      // we do this check for people who updated their code before we shipped wasChanged\n      result[0]?.state\n    ) {\n      const state = result[0]?.state as string; // could be null?\n\n      this.#state = JSON.parse(state);\n      return this.#state;\n    }\n\n    // ok, this is the first time the state is being accessed\n    // and the state was not set in a previous life\n    // so we need to set the initial state (if provided)\n    if (this.initialState === DEFAULT_STATE) {\n      // no initial state provided, so we return undefined\n      return undefined as State;\n    }\n    // initial state provided, so we set the state,\n    // update db and return the initial state\n    this.setState(this.initialState);\n    return this.initialState;\n  }\n\n  /**\n   * Agent configuration options\n   */\n  static options = {\n    /** Whether the Agent should hibernate when inactive */\n    hibernate: true, // default to hibernate\n  };\n\n  /**\n   * Execute SQL queries against the Agent's database\n   * @template T Type of the returned rows\n   * @param strings SQL query template strings\n   * @param values Values to be inserted into the query\n   * @returns Array of query results\n   */\n  sql<T = Record<string, string | number | boolean | null>>(\n    strings: TemplateStringsArray,\n    ...values: (string | number | boolean | null)[]\n  ) {\n    let query = \"\";\n    try {\n      // Construct the SQL query with placeholders\n      query = strings.reduce(\n        (acc, str, i) => acc + str + (i < values.length ? \"?\" : \"\"),\n        \"\"\n      );\n\n      // Execute the SQL query with the provided values\n      return [...this.ctx.storage.sql.exec(query, ...values)] as T[];\n    } catch (e) {\n      console.error(`failed to execute sql query: ${query}`, e);\n      throw this.onError(e);\n    }\n  }\n  constructor(ctx: AgentContext, env: Env) {\n    super(ctx, env);\n\n    this.sql`\n      CREATE TABLE IF NOT EXISTS cf_agents_state (\n        id TEXT PRIMARY KEY NOT NULL,\n        state TEXT\n      )\n    `;\n\n    void this.ctx.blockConcurrencyWhile(async () => {\n      return this.#tryCatch(async () => {\n        // Create alarms table if it doesn't exist\n        this.sql`\n        CREATE TABLE IF NOT EXISTS cf_agents_schedules (\n          id TEXT PRIMARY KEY NOT NULL DEFAULT (randomblob(9)),\n          callback TEXT,\n          payload TEXT,\n          type TEXT NOT NULL CHECK(type IN ('scheduled', 'delayed', 'cron')),\n          time INTEGER,\n          delayInSeconds INTEGER,\n          cron TEXT,\n          created_at INTEGER DEFAULT (unixepoch())\n        )\n      `;\n\n        // execute any pending alarms and schedule the next alarm\n        await this.alarm();\n      });\n    });\n\n    this.sql`\n      CREATE TABLE IF NOT EXISTS cf_agents_mcp_servers (\n        id TEXT PRIMARY KEY NOT NULL,\n        name TEXT NOT NULL,\n        server_url TEXT NOT NULL,\n        callback_url TEXT NOT NULL,\n        client_id TEXT,\n        auth_url TEXT,\n        server_options TEXT\n      )\n    `;\n\n    const _onRequest = this.onRequest.bind(this);\n    this.onRequest = (request: Request) => {\n      return agentContext.run(\n        { agent: this, connection: undefined, request },\n        async () => {\n          if (this.mcp.isCallbackRequest(request)) {\n            await this.mcp.handleCallbackRequest(request);\n\n            // after the MCP connection handshake, we can send updated mcp state\n            this.broadcast(\n              JSON.stringify({\n                type: \"cf_agent_mcp_servers\",\n                mcp: this.#getMcpServerStateInternal(),\n              })\n            );\n\n            // We probably should let the user configure this response/redirect, but this is fine for now.\n            return new Response(\"<script>window.close();</script>\", {\n              status: 200,\n              headers: { \"content-type\": \"text/html\" },\n            });\n          }\n\n          return this.#tryCatch(() => _onRequest(request));\n        }\n      );\n    };\n\n    const _onMessage = this.onMessage.bind(this);\n    this.onMessage = async (connection: Connection, message: WSMessage) => {\n      return agentContext.run(\n        { agent: this, connection, request: undefined },\n        async () => {\n          if (typeof message !== \"string\") {\n            return this.#tryCatch(() => _onMessage(connection, message));\n          }\n\n          let parsed: unknown;\n          try {\n            parsed = JSON.parse(message);\n          } catch (e) {\n            // silently fail and let the onMessage handler handle it\n            return this.#tryCatch(() => _onMessage(connection, message));\n          }\n\n          if (isStateUpdateMessage(parsed)) {\n            this.#setStateInternal(parsed.state as State, connection);\n            return;\n          }\n\n          if (isRPCRequest(parsed)) {\n            try {\n              const { id, method, args } = parsed;\n\n              // Check if method exists and is callable\n              const methodFn = this[method as keyof this];\n              if (typeof methodFn !== \"function\") {\n                throw new Error(`Method ${method} does not exist`);\n              }\n\n              if (!this.#isCallable(method)) {\n                throw new Error(`Method ${method} is not callable`);\n              }\n\n              // biome-ignore lint/complexity/noBannedTypes: <explanation>\n              const metadata = callableMetadata.get(methodFn as Function);\n\n              // For streaming methods, pass a StreamingResponse object\n              if (metadata?.streaming) {\n                const stream = new StreamingResponse(connection, id);\n                await methodFn.apply(this, [stream, ...args]);\n                return;\n              }\n\n              // For regular methods, execute and send response\n              const result = await methodFn.apply(this, args);\n              const response: RPCResponse = {\n                type: \"rpc\",\n                id,\n                success: true,\n                result,\n                done: true,\n              };\n              connection.send(JSON.stringify(response));\n            } catch (e) {\n              // Send error response\n              const response: RPCResponse = {\n                type: \"rpc\",\n                id: parsed.id,\n                success: false,\n                error:\n                  e instanceof Error ? e.message : \"Unknown error occurred\",\n              };\n              connection.send(JSON.stringify(response));\n              console.error(\"RPC error:\", e);\n            }\n            return;\n          }\n\n          return this.#tryCatch(() => _onMessage(connection, message));\n        }\n      );\n    };\n\n    const _onConnect = this.onConnect.bind(this);\n    this.onConnect = (connection: Connection, ctx: ConnectionContext) => {\n      // TODO: This is a hack to ensure the state is sent after the connection is established\n      // must fix this\n      return agentContext.run(\n        { agent: this, connection, request: ctx.request },\n        async () => {\n          setTimeout(() => {\n            if (this.state) {\n              connection.send(\n                JSON.stringify({\n                  type: \"cf_agent_state\",\n                  state: this.state,\n                })\n              );\n            }\n\n            connection.send(\n              JSON.stringify({\n                type: \"cf_agent_mcp_servers\",\n                mcp: this.#getMcpServerStateInternal(),\n              })\n            );\n\n            return this.#tryCatch(() => _onConnect(connection, ctx));\n          }, 20);\n        }\n      );\n    };\n\n    const _onStart = this.onStart.bind(this);\n    this.onStart = async () => {\n      return agentContext.run(\n        { agent: this, connection: undefined, request: undefined },\n        async () => {\n          const servers = this.sql<MCPServerRow>`\n            SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;\n          `;\n\n          // from DO storage, reconnect to all servers using our saved auth information\n          await Promise.allSettled(\n            servers.map((server) => {\n              return this.#connectToMcpServerInternal(\n                server.name,\n                server.server_url,\n                server.callback_url,\n                server.server_options\n                  ? JSON.parse(server.server_options)\n                  : undefined,\n                {\n                  id: server.id,\n                  oauthClientId: server.client_id ?? undefined,\n                }\n              );\n            })\n          );\n\n          this.broadcast(\n            JSON.stringify({\n              type: \"cf_agent_mcp_servers\",\n              mcp: this.#getMcpServerStateInternal(),\n            })\n          );\n\n          await this.#tryCatch(() => _onStart());\n        }\n      );\n    };\n  }\n\n  #setStateInternal(state: State, source: Connection | \"server\" = \"server\") {\n    this.#state = state;\n    this.sql`\n    INSERT OR REPLACE INTO cf_agents_state (id, state)\n    VALUES (${STATE_ROW_ID}, ${JSON.stringify(state)})\n  `;\n    this.sql`\n    INSERT OR REPLACE INTO cf_agents_state (id, state)\n    VALUES (${STATE_WAS_CHANGED}, ${JSON.stringify(true)})\n  `;\n    this.broadcast(\n      JSON.stringify({\n        type: \"cf_agent_state\",\n        state: state,\n      }),\n      source !== \"server\" ? [source.id] : []\n    );\n    return this.#tryCatch(() => {\n      const { connection, request } = agentContext.getStore() || {};\n      return agentContext.run(\n        { agent: this, connection, request },\n        async () => {\n          return this.onStateUpdate(state, source);\n        }\n      );\n    });\n  }\n\n  /**\n   * Update the Agent's state\n   * @param state New state to set\n   */\n  setState(state: State) {\n    this.#setStateInternal(state, \"server\");\n  }\n\n  /**\n   * Called when the Agent's state is updated\n   * @param state Updated state\n   * @param source Source of the state update (\"server\" or a client connection)\n   */\n  onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n    // override this to handle state updates\n  }\n\n  /**\n   * Called when the Agent receives an email\n   * @param email Email message to process\n   */\n  onEmail(email: ForwardableEmailMessage) {\n    return agentContext.run(\n      { agent: this, connection: undefined, request: undefined },\n      async () => {\n        console.error(\"onEmail not implemented\");\n      }\n    );\n  }\n\n  async #tryCatch<T>(fn: () => T | Promise<T>) {\n    try {\n      return await fn();\n    } catch (e) {\n      throw this.onError(e);\n    }\n  }\n\n  override onError(\n    connection: Connection,\n    error: unknown\n  ): void | Promise<void>;\n  override onError(error: unknown): void | Promise<void>;\n  override onError(connectionOrError: Connection | unknown, error?: unknown) {\n    let theError: unknown;\n    if (connectionOrError && error) {\n      theError = error;\n      // this is a websocket connection error\n      console.error(\n        \"Error on websocket connection:\",\n        (connectionOrError as Connection).id,\n        theError\n      );\n      console.error(\n        \"Override onError(connection, error) to handle websocket connection errors\"\n      );\n    } else {\n      theError = connectionOrError;\n      // this is a server error\n      console.error(\"Error on server:\", theError);\n      console.error(\"Override onError(error) to handle server errors\");\n    }\n    throw theError;\n  }\n\n  /**\n   * Render content (not implemented in base class)\n   */\n  render() {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Schedule a task to be executed in the future\n   * @template T Type of the payload data\n   * @param when When to execute the task (Date, seconds delay, or cron expression)\n   * @param callback Name of the method to call\n   * @param payload Data to pass to the callback\n   * @returns Schedule object representing the scheduled task\n   */\n  async schedule<T = string>(\n    when: Date | string | number,\n    callback: keyof this,\n    payload?: T\n  ): Promise<Schedule<T>> {\n    const id = nanoid(9);\n\n    if (typeof callback !== \"string\") {\n      throw new Error(\"Callback must be a string\");\n    }\n\n    if (typeof this[callback] !== \"function\") {\n      throw new Error(`this.${callback} is not a function`);\n    }\n\n    if (when instanceof Date) {\n      const timestamp = Math.floor(when.getTime() / 1000);\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'scheduled', ${timestamp})\n      `;\n\n      await this.#scheduleNextAlarm();\n\n      return {\n        id,\n        callback: callback,\n        payload: payload as T,\n        time: timestamp,\n        type: \"scheduled\",\n      };\n    }\n    if (typeof when === \"number\") {\n      const time = new Date(Date.now() + when * 1000);\n      const timestamp = Math.floor(time.getTime() / 1000);\n\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, delayInSeconds, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'delayed', ${when}, ${timestamp})\n      `;\n\n      await this.#scheduleNextAlarm();\n\n      return {\n        id,\n        callback: callback,\n        payload: payload as T,\n        delayInSeconds: when,\n        time: timestamp,\n        type: \"delayed\",\n      };\n    }\n    if (typeof when === \"string\") {\n      const nextExecutionTime = getNextCronTime(when);\n      const timestamp = Math.floor(nextExecutionTime.getTime() / 1000);\n\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, cron, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'cron', ${when}, ${timestamp})\n      `;\n\n      await this.#scheduleNextAlarm();\n\n      return {\n        id,\n        callback: callback,\n        payload: payload as T,\n        cron: when,\n        time: timestamp,\n        type: \"cron\",\n      };\n    }\n    throw new Error(\"Invalid schedule type\");\n  }\n\n  /**\n   * Get a scheduled task by ID\n   * @template T Type of the payload data\n   * @param id ID of the scheduled task\n   * @returns The Schedule object or undefined if not found\n   */\n  async getSchedule<T = string>(id: string): Promise<Schedule<T> | undefined> {\n    const result = this.sql<Schedule<string>>`\n      SELECT * FROM cf_agents_schedules WHERE id = ${id}\n    `;\n    if (!result) {\n      console.error(`schedule ${id} not found`);\n      return undefined;\n    }\n\n    return { ...result[0], payload: JSON.parse(result[0].payload) as T };\n  }\n\n  /**\n   * Get scheduled tasks matching the given criteria\n   * @template T Type of the payload data\n   * @param criteria Criteria to filter schedules\n   * @returns Array of matching Schedule objects\n   */\n  getSchedules<T = string>(\n    criteria: {\n      id?: string;\n      type?: \"scheduled\" | \"delayed\" | \"cron\";\n      timeRange?: { start?: Date; end?: Date };\n    } = {}\n  ): Schedule<T>[] {\n    let query = \"SELECT * FROM cf_agents_schedules WHERE 1=1\";\n    const params = [];\n\n    if (criteria.id) {\n      query += \" AND id = ?\";\n      params.push(criteria.id);\n    }\n\n    if (criteria.type) {\n      query += \" AND type = ?\";\n      params.push(criteria.type);\n    }\n\n    if (criteria.timeRange) {\n      query += \" AND time >= ? AND time <= ?\";\n      const start = criteria.timeRange.start || new Date(0);\n      const end = criteria.timeRange.end || new Date(999999999999999);\n      params.push(\n        Math.floor(start.getTime() / 1000),\n        Math.floor(end.getTime() / 1000)\n      );\n    }\n\n    const result = this.ctx.storage.sql\n      .exec(query, ...params)\n      .toArray()\n      .map((row) => ({\n        ...row,\n        payload: JSON.parse(row.payload as string) as T,\n      })) as Schedule<T>[];\n\n    return result;\n  }\n\n  /**\n   * Cancel a scheduled task\n   * @param id ID of the task to cancel\n   * @returns true if the task was cancelled, false otherwise\n   */\n  async cancelSchedule(id: string): Promise<boolean> {\n    this.sql`DELETE FROM cf_agents_schedules WHERE id = ${id}`;\n\n    await this.#scheduleNextAlarm();\n    return true;\n  }\n\n  async #scheduleNextAlarm() {\n    // Find the next schedule that needs to be executed\n    const result = this.sql`\n      SELECT time FROM cf_agents_schedules \n      WHERE time > ${Math.floor(Date.now() / 1000)}\n      ORDER BY time ASC \n      LIMIT 1\n    `;\n    if (!result) return;\n\n    if (result.length > 0 && \"time\" in result[0]) {\n      const nextTime = (result[0].time as number) * 1000;\n      await this.ctx.storage.setAlarm(nextTime);\n    }\n  }\n\n  /**\n   * Method called when an alarm fires.\n   * Executes any scheduled tasks that are due.\n   *\n   * @remarks\n   * To schedule a task, please use the `this.schedule` method instead.\n   * See {@link https://developers.cloudflare.com/agents/api-reference/schedule-tasks/}\n   */\n  public readonly alarm = async () => {\n    const now = Math.floor(Date.now() / 1000);\n\n    // Get all schedules that should be executed now\n    const result = this.sql<Schedule<string>>`\n      SELECT * FROM cf_agents_schedules WHERE time <= ${now}\n    `;\n\n    for (const row of result || []) {\n      const callback = this[row.callback as keyof Agent<Env>];\n      if (!callback) {\n        console.error(`callback ${row.callback} not found`);\n        continue;\n      }\n      await agentContext.run(\n        { agent: this, connection: undefined, request: undefined },\n        async () => {\n          try {\n            await (\n              callback as (\n                payload: unknown,\n                schedule: Schedule<unknown>\n              ) => Promise<void>\n            ).bind(this)(JSON.parse(row.payload as string), row);\n          } catch (e) {\n            console.error(`error executing callback \"${row.callback}\"`, e);\n          }\n        }\n      );\n      if (row.type === \"cron\") {\n        // Update next execution time for cron schedules\n        const nextExecutionTime = getNextCronTime(row.cron);\n        const nextTimestamp = Math.floor(nextExecutionTime.getTime() / 1000);\n\n        this.sql`\n          UPDATE cf_agents_schedules SET time = ${nextTimestamp} WHERE id = ${row.id}\n        `;\n      } else {\n        // Delete one-time schedules after execution\n        this.sql`\n          DELETE FROM cf_agents_schedules WHERE id = ${row.id}\n        `;\n      }\n    }\n\n    // Schedule the next alarm\n    await this.#scheduleNextAlarm();\n  };\n\n  /**\n   * Destroy the Agent, removing all state and scheduled tasks\n   */\n  async destroy() {\n    // drop all tables\n    this.sql`DROP TABLE IF EXISTS cf_agents_state`;\n    this.sql`DROP TABLE IF EXISTS cf_agents_schedules`;\n    this.sql`DROP TABLE IF EXISTS cf_agents_mcp_servers`;\n\n    // delete all alarms\n    await this.ctx.storage.deleteAlarm();\n    await this.ctx.storage.deleteAll();\n  }\n\n  /**\n   * Get all methods marked as callable on this Agent\n   * @returns A map of method names to their metadata\n   */\n  #isCallable(method: string): boolean {\n    // biome-ignore lint/complexity/noBannedTypes: <explanation>\n    return callableMetadata.has(this[method as keyof this] as Function);\n  }\n\n  /**\n   * Connect to a new MCP Server\n   *\n   * @param url MCP Server SSE URL\n   * @param callbackHost Base host for the agent, used for the redirect URI.\n   * @param agentsPrefix agents routing prefix if not using `agents`\n   * @param options MCP client and transport (header) options\n   * @returns authUrl\n   */\n  async addMcpServer(\n    serverName: string,\n    url: string,\n    callbackHost: string,\n    agentsPrefix = \"agents\",\n    options?: {\n      client?: ConstructorParameters<typeof Client>[1];\n      transport?: {\n        headers: HeadersInit;\n      };\n    }\n  ): Promise<{ id: string; authUrl: string | undefined }> {\n    const callbackUrl = `${callbackHost}/${agentsPrefix}/${camelCaseToKebabCase(this.#ParentClass.name)}/${this.name}/callback`;\n\n    const result = await this.#connectToMcpServerInternal(\n      serverName,\n      url,\n      callbackUrl,\n      options\n    );\n\n    this.broadcast(\n      JSON.stringify({\n        type: \"cf_agent_mcp_servers\",\n        mcp: this.#getMcpServerStateInternal(),\n      })\n    );\n\n    return result;\n  }\n\n  async #connectToMcpServerInternal(\n    serverName: string,\n    url: string,\n    callbackUrl: string,\n    // it's important that any options here are serializable because we put them into our sqlite DB for reconnection purposes\n    options?: {\n      client?: ConstructorParameters<typeof Client>[1];\n      /**\n       * We don't expose the normal set of transport options because:\n       * 1) we can't serialize things like the auth provider or a fetch function into the DB for reconnection purposes\n       * 2) We probably want these options to be agnostic to the transport type (SSE vs Streamable)\n       *\n       * This has the limitation that you can't override fetch, but I think headers should handle nearly all cases needed (i.e. non-standard bearer auth).\n       */\n      transport?: {\n        headers?: HeadersInit;\n      };\n    },\n    reconnect?: {\n      id: string;\n      oauthClientId?: string;\n    }\n  ): Promise<{ id: string; authUrl: string | undefined }> {\n    const authProvider = new DurableObjectOAuthClientProvider(\n      this.ctx.storage,\n      this.name,\n      callbackUrl\n    );\n\n    if (reconnect) {\n      authProvider.serverId = reconnect.id;\n      if (reconnect.oauthClientId) {\n        authProvider.clientId = reconnect.oauthClientId;\n      }\n    }\n\n    // allows passing through transport headers if necessary\n    // this handles some non-standard bearer auth setups (i.e. MCP server behind CF access instead of OAuth)\n    let headerTransportOpts: SSEClientTransportOptions = {};\n    if (options?.transport?.headers) {\n      headerTransportOpts = {\n        eventSourceInit: {\n          fetch: (url, init) =>\n            fetch(url, {\n              ...init,\n              headers: options?.transport?.headers,\n            }),\n        },\n        requestInit: {\n          headers: options?.transport?.headers,\n        },\n      };\n    }\n\n    const { id, authUrl, clientId } = await this.mcp.connect(url, {\n      reconnect,\n      transport: {\n        ...headerTransportOpts,\n        authProvider,\n      },\n      client: options?.client,\n    });\n\n    this.sql`\n      INSERT OR REPLACE INTO cf_agents_mcp_servers (id, name, server_url, client_id, auth_url, callback_url, server_options)\n      VALUES (\n        ${id},\n        ${serverName},\n        ${url},\n        ${clientId ?? null},\n        ${authUrl ?? null},\n        ${callbackUrl},\n        ${options ? JSON.stringify(options) : null}\n      );\n    `;\n\n    return {\n      id,\n      authUrl,\n    };\n  }\n\n  async removeMcpServer(id: string) {\n    this.mcp.closeConnection(id);\n    this.sql`\n      DELETE FROM cf_agents_mcp_servers WHERE id = ${id};\n    `;\n    this.broadcast(\n      JSON.stringify({\n        type: \"cf_agent_mcp_servers\",\n        mcp: this.#getMcpServerStateInternal(),\n      })\n    );\n  }\n\n  #getMcpServerStateInternal(): MCPServersState {\n    const mcpState: MCPServersState = {\n      servers: {},\n      tools: this.mcp.listTools(),\n      prompts: this.mcp.listPrompts(),\n      resources: this.mcp.listResources(),\n    };\n\n    const servers = this.sql<MCPServerRow>`\n      SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;\n    `;\n\n    for (const server of servers) {\n      mcpState.servers[server.id] = {\n        name: server.name,\n        server_url: server.server_url,\n        auth_url: server.auth_url,\n        state: this.mcp.mcpConnections[server.id].connectionState,\n      };\n    }\n\n    return mcpState;\n  }\n}\n\n/**\n * Namespace for creating Agent instances\n * @template Agentic Type of the Agent class\n */\nexport type AgentNamespace<Agentic extends Agent<unknown>> =\n  DurableObjectNamespace<Agentic>;\n\n/**\n * Agent's durable context\n */\nexport type AgentContext = DurableObjectState;\n\n/**\n * Configuration options for Agent routing\n */\nexport type AgentOptions<Env> = PartyServerOptions<Env> & {\n  /**\n   * Whether to enable CORS for the Agent\n   */\n  cors?: boolean | HeadersInit | undefined;\n};\n\n/**\n * Route a request to the appropriate Agent\n * @param request Request to route\n * @param env Environment containing Agent bindings\n * @param options Routing options\n * @returns Response from the Agent or undefined if no route matched\n */\nexport async function routeAgentRequest<Env>(\n  request: Request,\n  env: Env,\n  options?: AgentOptions<Env>\n) {\n  const corsHeaders =\n    options?.cors === true\n      ? {\n          \"Access-Control-Allow-Origin\": \"*\",\n          \"Access-Control-Allow-Methods\": \"GET, POST, HEAD, OPTIONS\",\n          \"Access-Control-Allow-Credentials\": \"true\",\n          \"Access-Control-Max-Age\": \"86400\",\n        }\n      : options?.cors;\n\n  if (request.method === \"OPTIONS\") {\n    if (corsHeaders) {\n      return new Response(null, {\n        headers: corsHeaders,\n      });\n    }\n    console.warn(\n      \"Received an OPTIONS request, but cors was not enabled. Pass `cors: true` or `cors: { ...custom cors headers }` to routeAgentRequest to enable CORS.\"\n    );\n  }\n\n  let response = await routePartykitRequest(\n    request,\n    env as Record<string, unknown>,\n    {\n      prefix: \"agents\",\n      ...(options as PartyServerOptions<Record<string, unknown>>),\n    }\n  );\n\n  if (\n    response &&\n    corsHeaders &&\n    request.headers.get(\"upgrade\")?.toLowerCase() !== \"websocket\" &&\n    request.headers.get(\"Upgrade\")?.toLowerCase() !== \"websocket\"\n  ) {\n    response = new Response(response.body, {\n      headers: {\n        ...response.headers,\n        ...corsHeaders,\n      },\n    });\n  }\n  return response;\n}\n\n/**\n * Route an email to the appropriate Agent\n * @param email Email message to route\n * @param env Environment containing Agent bindings\n * @param options Routing options\n */\nexport async function routeAgentEmail<Env>(\n  email: ForwardableEmailMessage,\n  env: Env,\n  options?: AgentOptions<Env>\n): Promise<void> {}\n\n/**\n * Get or create an Agent by name\n * @template Env Environment type containing bindings\n * @template T Type of the Agent class\n * @param namespace Agent namespace\n * @param name Name of the Agent instance\n * @param options Options for Agent creation\n * @returns Promise resolving to an Agent instance stub\n */\nexport async function getAgentByName<Env, T extends Agent<Env>>(\n  namespace: AgentNamespace<T>,\n  name: string,\n  options?: {\n    jurisdiction?: DurableObjectJurisdiction;\n    locationHint?: DurableObjectLocationHint;\n  }\n) {\n  return getServerByName<Env, T>(namespace, name, options);\n}\n\n/**\n * A wrapper for streaming responses in callable methods\n */\nexport class StreamingResponse {\n  #connection: Connection;\n  #id: string;\n  #closed = false;\n\n  constructor(connection: Connection, id: string) {\n    this.#connection = connection;\n    this.#id = id;\n  }\n\n  /**\n   * Send a chunk of data to the client\n   * @param chunk The data to send\n   */\n  send(chunk: unknown) {\n    if (this.#closed) {\n      throw new Error(\"StreamingResponse is already closed\");\n    }\n    const response: RPCResponse = {\n      type: \"rpc\",\n      id: this.#id,\n      success: true,\n      result: chunk,\n      done: false,\n    };\n    this.#connection.send(JSON.stringify(response));\n  }\n\n  /**\n   * End the stream and send the final chunk (if any)\n   * @param finalChunk Optional final chunk of data to send\n   */\n  end(finalChunk?: unknown) {\n    if (this.#closed) {\n      throw new Error(\"StreamingResponse is already closed\");\n    }\n    this.#closed = true;\n    const response: RPCResponse = {\n      type: \"rpc\",\n      id: this.#id,\n      success: true,\n      result: finalChunk,\n      done: true,\n    };\n    this.#connection.send(JSON.stringify(response));\n  }\n}\n"],"mappings":"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","names":["ctx","url"]}