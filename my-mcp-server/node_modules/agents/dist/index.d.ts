import { Server, Connection, PartyServerOptions } from "partyserver";
export { Connection, ConnectionContext, WSMessage } from "partyserver";
import { MCPClientManager } from "./mcp/client.js";
import { Tool, Prompt, Resource } from "@modelcontextprotocol/sdk/types.js";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import "zod";
import "@modelcontextprotocol/sdk/client/sse.js";
import "./mcp/do-oauth-client-provider.js";
import "@modelcontextprotocol/sdk/client/auth.js";
import "@modelcontextprotocol/sdk/shared/auth.js";
import "@modelcontextprotocol/sdk/shared/protocol.js";
import "ai";

/**
 * RPC request message from client
 */
type RPCRequest = {
  type: "rpc";
  id: string;
  method: string;
  args: unknown[];
};
/**
 * State update message from client
 */
type StateUpdateMessage = {
  type: "cf_agent_state";
  state: unknown;
};
/**
 * RPC response message to client
 */
type RPCResponse = {
  type: "rpc";
  id: string;
} & (
  | {
      success: true;
      result: unknown;
      done?: false;
    }
  | {
      success: true;
      result: unknown;
      done: true;
    }
  | {
      success: false;
      error: string;
    }
);
/**
 * Metadata for a callable method
 */
type CallableMetadata = {
  /** Optional description of what the method does */
  description?: string;
  /** Whether the method supports streaming responses */
  streaming?: boolean;
};
/**
 * Decorator that marks a method as callable by clients
 * @param metadata Optional metadata about the callable method
 */
declare function unstable_callable(
  metadata?: CallableMetadata
): <This, Args extends unknown[], Return>(
  target: (this: This, ...args: Args) => Return,
  context: ClassMethodDecoratorContext
) => (this: This, ...args: Args) => Return;
/**
 * Represents a scheduled task within an Agent
 * @template T Type of the payload data
 */
type Schedule<T = string> = {
  /** Unique identifier for the schedule */
  id: string;
  /** Name of the method to be called */
  callback: string;
  /** Data to be passed to the callback */
  payload: T;
} & (
  | {
      /** Type of schedule for one-time execution at a specific time */
      type: "scheduled";
      /** Timestamp when the task should execute */
      time: number;
    }
  | {
      /** Type of schedule for delayed execution */
      type: "delayed";
      /** Timestamp when the task should execute */
      time: number;
      /** Number of seconds to delay execution */
      delayInSeconds: number;
    }
  | {
      /** Type of schedule for recurring execution based on cron expression */
      type: "cron";
      /** Timestamp for the next execution */
      time: number;
      /** Cron expression defining the schedule */
      cron: string;
    }
);
/**
 * MCP Server state update message from server -> Client
 */
type MCPServerMessage = {
  type: "cf_agent_mcp_servers";
  mcp: MCPServersState;
};
type MCPServersState = {
  servers: {
    [id: string]: MCPServer;
  };
  tools: Tool[];
  prompts: Prompt[];
  resources: Resource[];
};
type MCPServer = {
  name: string;
  server_url: string;
  auth_url: string | null;
  state: "authenticating" | "connecting" | "ready" | "discovering" | "failed";
};
declare function getCurrentAgent<
  T extends Agent<unknown, unknown> = Agent<unknown, unknown>,
>(): {
  agent: T | undefined;
  connection: Connection | undefined;
  request: Request<unknown, CfProperties<unknown>> | undefined;
};
/**
 * Base class for creating Agent implementations
 * @template Env Environment type containing bindings
 * @template State State type to store within the Agent
 */
declare class Agent<Env, State = unknown> extends Server<Env> {
  #private;
  mcp: MCPClientManager;
  /**
   * Initial state for the Agent
   * Override to provide default state values
   */
  initialState: State;
  /**
   * Current state of the Agent
   */
  get state(): State;
  /**
   * Agent configuration options
   */
  static options: {
    /** Whether the Agent should hibernate when inactive */
    hibernate: boolean;
  };
  /**
   * Execute SQL queries against the Agent's database
   * @template T Type of the returned rows
   * @param strings SQL query template strings
   * @param values Values to be inserted into the query
   * @returns Array of query results
   */
  sql<T = Record<string, string | number | boolean | null>>(
    strings: TemplateStringsArray,
    ...values: (string | number | boolean | null)[]
  ): T[];
  constructor(ctx: AgentContext, env: Env);
  /**
   * Update the Agent's state
   * @param state New state to set
   */
  setState(state: State): void;
  /**
   * Called when the Agent's state is updated
   * @param state Updated state
   * @param source Source of the state update ("server" or a client connection)
   */
  onStateUpdate(state: State | undefined, source: Connection | "server"): void;
  /**
   * Called when the Agent receives an email
   * @param email Email message to process
   */
  onEmail(email: ForwardableEmailMessage): Promise<void>;
  onError(connection: Connection, error: unknown): void | Promise<void>;
  onError(error: unknown): void | Promise<void>;
  /**
   * Render content (not implemented in base class)
   */
  render(): void;
  /**
   * Schedule a task to be executed in the future
   * @template T Type of the payload data
   * @param when When to execute the task (Date, seconds delay, or cron expression)
   * @param callback Name of the method to call
   * @param payload Data to pass to the callback
   * @returns Schedule object representing the scheduled task
   */
  schedule<T = string>(
    when: Date | string | number,
    callback: keyof this,
    payload?: T
  ): Promise<Schedule<T>>;
  /**
   * Get a scheduled task by ID
   * @template T Type of the payload data
   * @param id ID of the scheduled task
   * @returns The Schedule object or undefined if not found
   */
  getSchedule<T = string>(id: string): Promise<Schedule<T> | undefined>;
  /**
   * Get scheduled tasks matching the given criteria
   * @template T Type of the payload data
   * @param criteria Criteria to filter schedules
   * @returns Array of matching Schedule objects
   */
  getSchedules<T = string>(criteria?: {
    id?: string;
    type?: "scheduled" | "delayed" | "cron";
    timeRange?: {
      start?: Date;
      end?: Date;
    };
  }): Schedule<T>[];
  /**
   * Cancel a scheduled task
   * @param id ID of the task to cancel
   * @returns true if the task was cancelled, false otherwise
   */
  cancelSchedule(id: string): Promise<boolean>;
  /**
   * Method called when an alarm fires.
   * Executes any scheduled tasks that are due.
   *
   * @remarks
   * To schedule a task, please use the `this.schedule` method instead.
   * See {@link https://developers.cloudflare.com/agents/api-reference/schedule-tasks/}
   */
  readonly alarm: () => Promise<void>;
  /**
   * Destroy the Agent, removing all state and scheduled tasks
   */
  destroy(): Promise<void>;
  /**
   * Connect to a new MCP Server
   *
   * @param url MCP Server SSE URL
   * @param callbackHost Base host for the agent, used for the redirect URI.
   * @param agentsPrefix agents routing prefix if not using `agents`
   * @param options MCP client and transport (header) options
   * @returns authUrl
   */
  addMcpServer(
    serverName: string,
    url: string,
    callbackHost: string,
    agentsPrefix?: string,
    options?: {
      client?: ConstructorParameters<typeof Client>[1];
      transport?: {
        headers: HeadersInit;
      };
    }
  ): Promise<{
    id: string;
    authUrl: string | undefined;
  }>;
  removeMcpServer(id: string): Promise<void>;
}
/**
 * Namespace for creating Agent instances
 * @template Agentic Type of the Agent class
 */
type AgentNamespace<Agentic extends Agent<unknown>> =
  DurableObjectNamespace<Agentic>;
/**
 * Agent's durable context
 */
type AgentContext = DurableObjectState;
/**
 * Configuration options for Agent routing
 */
type AgentOptions<Env> = PartyServerOptions<Env> & {
  /**
   * Whether to enable CORS for the Agent
   */
  cors?: boolean | HeadersInit | undefined;
};
/**
 * Route a request to the appropriate Agent
 * @param request Request to route
 * @param env Environment containing Agent bindings
 * @param options Routing options
 * @returns Response from the Agent or undefined if no route matched
 */
declare function routeAgentRequest<Env>(
  request: Request,
  env: Env,
  options?: AgentOptions<Env>
): Promise<Response | null>;
/**
 * Route an email to the appropriate Agent
 * @param email Email message to route
 * @param env Environment containing Agent bindings
 * @param options Routing options
 */
declare function routeAgentEmail<Env>(
  email: ForwardableEmailMessage,
  env: Env,
  options?: AgentOptions<Env>
): Promise<void>;
/**
 * Get or create an Agent by name
 * @template Env Environment type containing bindings
 * @template T Type of the Agent class
 * @param namespace Agent namespace
 * @param name Name of the Agent instance
 * @param options Options for Agent creation
 * @returns Promise resolving to an Agent instance stub
 */
declare function getAgentByName<Env, T extends Agent<Env>>(
  namespace: AgentNamespace<T>,
  name: string,
  options?: {
    jurisdiction?: DurableObjectJurisdiction;
    locationHint?: DurableObjectLocationHint;
  }
): Promise<DurableObjectStub<T>>;
/**
 * A wrapper for streaming responses in callable methods
 */
declare class StreamingResponse {
  #private;
  constructor(connection: Connection, id: string);
  /**
   * Send a chunk of data to the client
   * @param chunk The data to send
   */
  send(chunk: unknown): void;
  /**
   * End the stream and send the final chunk (if any)
   * @param finalChunk Optional final chunk of data to send
   */
  end(finalChunk?: unknown): void;
}

export {
  Agent,
  type AgentContext,
  type AgentNamespace,
  type AgentOptions,
  type CallableMetadata,
  type MCPServer,
  type MCPServerMessage,
  type MCPServersState,
  type RPCRequest,
  type RPCResponse,
  type Schedule,
  type StateUpdateMessage,
  StreamingResponse,
  getAgentByName,
  getCurrentAgent,
  routeAgentEmail,
  routeAgentRequest,
  unstable_callable,
};
