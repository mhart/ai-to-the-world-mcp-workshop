{"version":3,"sources":["../src/ai-react.tsx"],"sourcesContent":["import { useChat } from \"@ai-sdk/react\";\nimport type { Message } from \"ai\";\nimport { use, useEffect } from \"react\";\nimport type { OutgoingMessage } from \"./ai-types\";\nimport type { useAgent } from \"./react\";\nimport { nanoid } from \"nanoid\";\n\ntype GetInitialMessagesOptions = {\n  agent: string;\n  name: string;\n  url: string;\n};\n\n/**\n * Options for the useAgentChat hook\n */\ntype UseAgentChatOptions<State> = Omit<\n  Parameters<typeof useChat>[0] & {\n    /** Agent connection from useAgent */\n    agent: ReturnType<typeof useAgent<State>>;\n    getInitialMessages?:\n      | undefined\n      | null\n      // | (() => Message[])\n      | ((options: GetInitialMessagesOptions) => Promise<Message[]>);\n  },\n  \"fetch\"\n>;\n\nconst requestCache = new Map<string, Promise<Message[]>>();\n\n/**\n * React hook for building AI chat interfaces using an Agent\n * @param options Chat options including the agent connection\n * @returns Chat interface controls and state with added clearHistory method\n */\nexport function useAgentChat<State = unknown>(\n  options: UseAgentChatOptions<State>\n) {\n  const { agent, getInitialMessages, ...rest } = options;\n\n  const agentUrl = new URL(\n    `${// @ts-expect-error we're using a protected _url property that includes query params\n    ((agent._url as string | null) || agent._pkurl)\n      ?.replace(\"ws://\", \"http://\")\n      .replace(\"wss://\", \"https://\")}`\n  );\n\n  // delete the _pk query param\n  agentUrl.searchParams.delete(\"_pk\");\n  const agentUrlString = agentUrl.toString();\n\n  async function defaultGetInitialMessagesFetch({\n    url,\n  }: GetInitialMessagesOptions) {\n    const getMessagesUrl = new URL(url);\n    getMessagesUrl.pathname += \"/get-messages\";\n    const response = await fetch(getMessagesUrl.toString(), {\n      headers: options.headers,\n      credentials: options.credentials,\n    });\n    return response.json<Message[]>();\n  }\n\n  const getInitialMessagesFetch =\n    getInitialMessages || defaultGetInitialMessagesFetch;\n\n  function doGetInitialMessages(\n    getInitialMessagesOptions: GetInitialMessagesOptions\n  ) {\n    if (requestCache.has(agentUrlString)) {\n      return requestCache.get(agentUrlString)!;\n    }\n    const promise = getInitialMessagesFetch(getInitialMessagesOptions);\n    // immediately cache the promise so that we don't\n    // create multiple requests for the same agent during multiple\n    // concurrent renders\n    requestCache.set(agentUrlString, promise);\n    return promise;\n  }\n\n  const initialMessagesPromise =\n    getInitialMessages === null\n      ? null\n      : doGetInitialMessages({\n          agent: agent.agent,\n          name: agent.name,\n          url: agentUrlString,\n        });\n  const initialMessages = initialMessagesPromise\n    ? use(initialMessagesPromise)\n    : (rest.initialMessages ?? []);\n\n  // manages adding and removing the promise from the cache\n  useEffect(() => {\n    if (!initialMessagesPromise) {\n      return;\n    }\n    // this effect is responsible for removing the promise from the cache\n    // when the component unmounts or the promise changes,\n    // but that means it also must add the promise to the cache\n    // so that multiple arbitrary effect runs produce the expected state\n    // when resolved.\n    requestCache.set(agentUrlString, initialMessagesPromise!);\n    return () => {\n      if (requestCache.get(agentUrlString) === initialMessagesPromise) {\n        requestCache.delete(agentUrlString);\n      }\n    };\n  }, [agentUrlString, initialMessagesPromise]);\n\n  async function aiFetch(\n    request: RequestInfo | URL,\n    options: RequestInit = {}\n  ) {\n    // we're going to use a websocket to do the actual \"fetching\"\n    // but still satisfy the type signature of the fetch function\n    // so we'll return a promise that resolves to a response\n\n    const {\n      method,\n      keepalive,\n      headers,\n      body,\n      redirect,\n      integrity,\n      signal,\n      credentials,\n      mode,\n      referrer,\n      referrerPolicy,\n      window,\n      //  dispatcher, duplex\n    } = options;\n    const id = nanoid(8);\n    const abortController = new AbortController();\n\n    signal?.addEventListener(\"abort\", () => {\n      // Propagate request cancellation to the Agent\n      // We need to communciate cancellation as a websocket message, instead of a request signal\n      agent.send(\n        JSON.stringify({\n          type: \"cf_agent_chat_request_cancel\",\n          id,\n        })\n      );\n\n      // NOTE - If we wanted to, we could preserve the \"interrupted\" message here, with the code below\n      //        However, I think it might be the responsibility of the library user to implement that behavior manually?\n      //        Reasoning: This code could be subject to collisions, as it \"force saves\" the messages we have locally\n      //\n      // agent.send(JSON.stringify({\n      //   type: \"cf_agent_chat_messages\",\n      //   messages: ... /* some way of getting current messages ref? */\n      // }))\n\n      abortController.abort();\n      // Make sure to also close the stream (cf. https://github.com/cloudflare/agents-starter/issues/69)\n      controller.close();\n    });\n\n    agent.addEventListener(\n      \"message\",\n      (event) => {\n        let data: OutgoingMessage;\n        try {\n          data = JSON.parse(event.data) as OutgoingMessage;\n        } catch (error) {\n          // silently ignore invalid messages for now\n          // TODO: log errors with log levels\n          return;\n        }\n        if (data.type === \"cf_agent_use_chat_response\") {\n          if (data.id === id) {\n            controller.enqueue(new TextEncoder().encode(data.body));\n            if (data.done) {\n              controller.close();\n              abortController.abort();\n            }\n          }\n        }\n      },\n      { signal: abortController.signal }\n    );\n\n    let controller: ReadableStreamDefaultController;\n\n    const stream = new ReadableStream({\n      start(c) {\n        controller = c;\n      },\n    });\n\n    agent.send(\n      JSON.stringify({\n        type: \"cf_agent_use_chat_request\",\n        id,\n        url: request.toString(),\n        init: {\n          method,\n          keepalive,\n          headers,\n          body,\n          redirect,\n          integrity,\n          credentials,\n          mode,\n          referrer,\n          referrerPolicy,\n          window,\n          // dispatcher,\n          // duplex\n        },\n      })\n    );\n\n    return new Response(stream);\n  }\n  const useChatHelpers = useChat({\n    initialMessages,\n    sendExtraMessageFields: true,\n    fetch: aiFetch,\n    ...rest,\n  });\n\n  useEffect(() => {\n    function onClearHistory(event: MessageEvent) {\n      if (typeof event.data !== \"string\") {\n        return;\n      }\n      let data: OutgoingMessage;\n      try {\n        data = JSON.parse(event.data) as OutgoingMessage;\n      } catch (error) {\n        // silently ignore invalid messages for now\n        // TODO: log errors with log levels\n        return;\n      }\n      if (data.type === \"cf_agent_chat_clear\") {\n        useChatHelpers.setMessages([]);\n      }\n    }\n\n    function onMessages(event: MessageEvent) {\n      if (typeof event.data !== \"string\") {\n        return;\n      }\n      let data: OutgoingMessage;\n      try {\n        data = JSON.parse(event.data) as OutgoingMessage;\n      } catch (error) {\n        // silently ignore invalid messages for now\n        // TODO: log errors with log levels\n        return;\n      }\n      if (data.type === \"cf_agent_chat_messages\") {\n        useChatHelpers.setMessages(data.messages);\n      }\n    }\n\n    agent.addEventListener(\"message\", onClearHistory);\n    agent.addEventListener(\"message\", onMessages);\n\n    return () => {\n      agent.removeEventListener(\"message\", onClearHistory);\n      agent.removeEventListener(\"message\", onMessages);\n    };\n  }, [agent, useChatHelpers.setMessages]);\n\n  return {\n    ...useChatHelpers,\n    /**\n     * Set the chat messages and synchronize with the Agent\n     * @param messages New messages to set\n     */\n    setMessages: (messages: Message[]) => {\n      useChatHelpers.setMessages(messages);\n      agent.send(\n        JSON.stringify({\n          type: \"cf_agent_chat_messages\",\n          messages,\n        })\n      );\n    },\n    /**\n     * Clear chat history on both client and Agent\n     */\n    clearHistory: () => {\n      useChatHelpers.setMessages([]);\n      agent.send(\n        JSON.stringify({\n          type: \"cf_agent_chat_clear\",\n        })\n      );\n    },\n  };\n}\n"],"mappings":"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","names":["options"]}